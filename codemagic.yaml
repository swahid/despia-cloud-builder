workflows:
  despia-app-builder:
    name: Despia Cloud Web App Builder
    instance_type: mac_mini_m2
    max_build_duration: 30

    environment:
      groups:
        - webapp_secrets
      vars:
        CLIENT_ID: $CLIENT_ID
        CLIENT_ASSET_URL: $CLIENT_ASSET_URL
        CALLBACK_URL: $CALLBACK_URL
      node: latest
      npm: latest

    scripts:
      - name: Install Dependencies
        script: |
          #!/bin/bash
          # Install build dependencies
          brew install jq
          npm install -g npm@latest yarn@latest
          
          # Create callback utilities (write to a file under the build dir)
          cat > /tmp/callback_functions.sh <<'CALLBACK_EOF'
          #!/bin/bash
          export CM_ARTIFACT_URL="https://app.codemagic.io/app/$CM_APP_ID/build/$CM_BUILD_ID/artifacts"

          send_callback() {
            local status="$1"
            local message="$2"
            local output_url="${3:-}"

            echo "Sending $status callback to $CALLBACK_URL"

            # Build compact JSON safely with jq and stream it to curl to avoid argument parsing issues
            JSON_PAYLOAD=$(jq -c -n \
              --arg bid "$CM_BUILD_ID" \
              --arg cid "$CLIENT_ID" \
              --arg url "$output_url" \
              --arg stat "$status" \
              --arg msg "$message" \
              '{build_id: $bid, client_id: $cid, output_url: $url, status: $stat, message: $msg}')

            MAX_RETRIES=5
            DELAY=2
            for i in $(seq 1 $MAX_RETRIES); do
              echo "Attempt $i: Sending callback"
              # Pipe JSON into curl to avoid curl interpreting leading characters as options
              printf '%s' "$JSON_PAYLOAD" | curl -fs -H "Content-Type: application/json" --data-binary @- "$CALLBACK_URL" && return 0
              echo "Callback failed. Retrying in $DELAY seconds..."
              sleep $DELAY
              DELAY=$((DELAY * 2))
            done
            echo "ERROR: Failed to send callback after $MAX_RETRIES attempts"
            return 1
          }

          send_failure_callback() {
            send_callback "failed" "$1" ""
            exit 1
          }

          export -f send_callback send_failure_callback
          CALLBACK_EOF

          chmod +x /tmp/callback_functions.sh
          echo "Callback functions prepared and saved to /tmp/callback_functions.sh."
          
      - name: Fetch Source Code
        script: |
          #!/bin/bash
          source /tmp/callback_functions.sh || send_failure_callback "Failed to source callback functions"

          echo "Processing Build: $CM_BUILD_ID for Client: $CLIENT_ID"
          # Use Codemagic provided build dir (create a subfolder 'source')
          WORKSPACE_DIR="${CM_BUILD_DIR:-/tmp}/source"
          mkdir -p "$WORKSPACE_DIR"
          cd "$WORKSPACE_DIR" || send_failure_callback "Failed to enter workspace dir: $WORKSPACE_DIR"

          # Simple asset URL handling: expect CLIENT_ASSET_URL to end with .git or .zip
          if [[ "$CLIENT_ASSET_URL" =~ \.git$ ]]; then
            send_callback "in_progress" "Cloning Git repository from CLIENT_ASSET_URL..."
            git clone "$CLIENT_ASSET_URL" . || send_failure_callback "Git clone failed for $CLIENT_ASSET_URL"

            if [ -n "$SOURCE_BRANCH" ]; then
              git checkout "$SOURCE_BRANCH" || send_failure_callback "Branch checkout failed: $SOURCE_BRANCH"
            fi

          elif [[ "$CLIENT_ASSET_URL" =~ \.zip$ ]]; then
            send_callback "in_progress" "Downloading ZIP from CLIENT_ASSET_URL..."
            wget -q -O source.zip "$CLIENT_ASSET_URL" || send_failure_callback "ZIP download failed for $CLIENT_ASSET_URL"
            unzip -q source.zip || send_failure_callback "ZIP extraction failed"
            rm -f source.zip

          else
            send_failure_callback "CLIENT_ASSET_URL is not a .git or .zip URL: $CLIENT_ASSET_URL"
          fi

          [ -z "$(ls -A .)" ] && send_failure_callback "Empty workspace after fetch"
          send_callback "in_progress" "Source code fetched"

      - name: Build Web Project
        script: |
          #!/bin/bash
          # Load previously defined functions
          . /tmp/callback_functions.sh

          # Work inside the same source directory used by the fetch step
          SOURCE_DIR="${CM_BUILD_DIR:-/tmp}/source"
          cd "$SOURCE_DIR" || send_failure_callback "Failed to navigate into source directory: $SOURCE_DIR"

          # If the fetch produced a single top-level directory, flatten it
          if [[ $(find . -maxdepth 1 -mindepth 1 -type d | wc -l) -eq 1 ]]; then
            DIR_TO_MOVE=$(find . -maxdepth 1 -mindepth 1 -type d -print -quit)
            echo "Detected single top-level directory ($DIR_TO_MOVE), flattening structure."
            mv "$DIR_TO_MOVE"/* .
            rmdir "$DIR_TO_MOVE" || true
          fi

          if [ ! -f package.json ]; then
            send_failure_callback "Could not find package.json in the source code root. Cannot determine framework."
          fi

          echo "Installing Node dependencies..."
          if [ -f "yarn.lock" ]; then
            yarn install || send_failure_callback "yarn install failed"
          else
            npm install || send_failure_callback "npm install failed"
          fi

          PACKAGE_CONTENT=$(cat package.json)
          FRAMEWORK=""
          DIST_FOLDER=""

          if echo "$PACKAGE_CONTENT" | grep -q '"next"'; then
            FRAMEWORK="Next.js"
            DIST_FOLDER=".next"
          elif echo "$PACKAGE_CONTENT" | grep -q '"react"' && echo "$PACKAGE_CONTENT" | grep -q '"react-scripts"'; then
            FRAMEWORK="CRA-React"
            DIST_FOLDER="build"
          elif echo "$PACKAGE_CONTENT" | grep -q '"react"' && echo "$PACKAGE_CONTENT" | grep -q '"vite"'; then
            FRAMEWORK="Vite-React"
            DIST_FOLDER="dist"
          elif echo "$PACKAGE_CONTENT" | grep -q '"vue"'; then
            FRAMEWORK="Vue.js"
            DIST_FOLDER="dist"
          else
            send_failure_callback "Unsupported framework detected. Only Next.js, React, and Vue.js are supported."
          fi

          echo "Detected Framework: $FRAMEWORK."

          BUILD_SUCCESS=0
          echo "Attempting standard build: npm run build"
          if npm run build; then
            echo "Standard 'npm run build' successful."
            BUILD_SUCCESS=1
          else
            echo "Standard 'npm run build' failed. Trying framework-specific fallback..."
            case "$FRAMEWORK" in
              "Next.js")
                npx next build && BUILD_SUCCESS=1 || true
                ;;
              "CRA-React")
                npx react-scripts build && BUILD_SUCCESS=1 || true
                ;;
              "Vite-React"|"Vue.js")
                npx vite build && BUILD_SUCCESS=1 || true
                ;;
              *)
                ;;
            esac
          fi

          if [ $BUILD_SUCCESS -eq 0 ]; then
            send_failure_callback "Build failed for $FRAMEWORK project."
          fi

          # Verify distribution folder
          if [ ! -d "$DIST_FOLDER" ]; then
            send_failure_callback "Build succeeded, but the expected distribution folder ($DIST_FOLDER) was not found."
          fi

          # Persist the detected folder name
          echo "$DIST_FOLDER" > /tmp/dist_folder_name.txt
          echo "Web project built successfully. Distribution folder: $DIST_FOLDER"
      - name: Create Distribution ZIP
        script: |
          #!/bin/bash
          . /tmp/callback_functions.sh
          SOURCE_DIR="${CM_BUILD_DIR:-/tmp}/source"
          cd "$SOURCE_DIR" || send_failure_callback "Failed to navigate into source directory for zipping."
          
          # Get the distribution folder name saved during build
          DIST_FOLDER=$(cat /tmp/dist_folder_name.txt)
          OUTPUT_ZIP_NAME="web-app-dist.zip"
          
          echo "Creating distribution archive..."
          echo "Source directory: $SOURCE_DIR"
          echo "Distribution folder: $DIST_FOLDER"
          echo "Output ZIP: $OUTPUT_ZIP_NAME"
          
          # Ensure distribution folder exists
          if [ ! -d "$DIST_FOLDER" ]; then
            send_failure_callback "Distribution folder $DIST_FOLDER not found!"
          fi
          
          # Create the ZIP archive
          if ! zip -r "$CM_BUILD_DIR/$OUTPUT_ZIP_NAME" "$DIST_FOLDER"; then
            send_failure_callback "Failed to create ZIP archive from $DIST_FOLDER"
          fi
          
          echo "Successfully created artifact: $OUTPUT_ZIP_NAME"

    cache:
      cache_paths:
        - $CM_BUILD_DIR/node_modules

    # Artifacts section: Tells Codemagic what file to upload and make available
    artifacts:
      - web-app-dist.zip

    publishing:
      scripts:
        - name: Make Artifact Public and Send Callback
          script: |
            #!/bin/bash
            . /tmp/callback_functions.sh
            
            # Define the artifact name
            OUTPUT_ZIP_NAME="web-app-dist.zip"
            
            # Get public URL for the artifact using Codemagic API
            echo "Getting public URL for artifact..."
            PUBLIC_URL=$(curl -s -H "Content-Type: application/json" \
              -H "x-auth-token: $CM_API_KEY" \
              "https://api.codemagic.io/builds/$CM_BUILD_ID/artifacts/$OUTPUT_ZIP_NAME/public-url" | \
              jq -r '.url')

            if [ -z "$PUBLIC_URL" ] || [ "$PUBLIC_URL" = "null" ]; then
              echo "Failed to get public URL. Falling back to private URL..."
              PUBLIC_URL="$CM_ARTIFACT_URL/$OUTPUT_ZIP_NAME"
            fi
            
            echo "Sending success callback..."
            echo "Build ID: $CM_BUILD_ID"
            echo "Client ID: $CLIENT_ID"
            echo "Public Artifact URL: $PUBLIC_URL"
            
            # Send the final success callback with the public URL
            send_callback "success" "Build completed successfully. Distribution ZIP created and published." "$PUBLIC_URL"
            echo "Final callback sent. Build process complete."