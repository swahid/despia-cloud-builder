workflows:
  despia-app-builder:
    name: Despia Cloud Web App Builder
    instance_type: mac_mini_m2
    max_build_duration: 30
    labels:
      - ${CLIENT_ID}
    environment:
      vars:
        CLIENT_ID: ${CLIENT_ID}
        CLIENT_ASSEST_URL: $CLIENT_ASSEST_URL
        CALLBACK_URL: $CALLBACK_URL
      # Use the latest Node.js version for the macOS environment
      node: latest 

    scripts:
      - name: Setup Utilities and Persist Callback Functions
        script: |
          #!/bin/bash
          
          # Install jq for robust JSON payload generation using Homebrew
          echo "Installing jq via brew..."
          brew install jq

          # Update npm and install latest yarn globally
          echo "Updating npm and yarn to latest global versions..."
          npm install -g npm@latest
          npm install -g yarn@latest

          # --- Define and export shell functions for persistence across script steps ---

          # Write function definitions to a temporary file
          cat << 'EOF' > /tmp/callback_functions.sh
            #!/bin/bash
            export CM_ARTIFACT_URL="https://app.codemagic.io/app/$CM_APP_ID/build/$CM_BUILD_ID/artifacts"

            send_callback() {
              local status=$1
              local message=$2
              local output_url=${3:-} 
              
              echo "Sending $status callback to $CALLBACK_URL with URL: $output_url"
              
              # Use jq to safely construct the JSON payload
              JSON_PAYLOAD=$(jq -n \
                --arg bid "$CM_BUILD_ID" \
                --arg cid "$CLIENT_ID" \
                --arg url "$output_url" \
                --arg stat "$status" \
                --arg msg "$message" \
                '{
                  "build_id": $bid,
                  "client_id": $cid,
                  "output_url": $url,
                  "status": $stat,
                  "message": $msg
                }')

              # Attempt to send callback with exponential backoff
              MAX_RETRIES=5
              DELAY=2
              for i in $(seq 1 $MAX_RETRIES); do
                echo "Attempt $i: Sending callback."
                # -s for silent, -f for fail on HTTP errors
                curl -fs -H "Content-Type: application/json" --data "$JSON_PAYLOAD" "$CALLBACK_URL" && return 0
                echo "Callback failed. Retrying in $DELAY seconds..."
                sleep $DELAY
                DELAY=$((DELAY * 2))
              done
              echo "ERROR: Failed to send final callback after $MAX_RETRIES attempts."
              return 1
            }
            export -f send_callback

            send_failure_callback() {
              send_callback "failed" "$1" ""
              exit 1 
            }
            export -f send_failure_callback
EOF
          echo "Callback functions prepared and saved to /tmp/callback_functions.sh."
          
      - name: 1. Fetch Source Code (Git or Zip)
        script: |
          #!/bin/bash
          # Load previously defined functions
          . /tmp/callback_functions.sh
          
          # Check if the URL contains .git to assume it's a Git repository
          if [[ "$CLIENT_ASSEST_URL" == *".git"* ]]; then
            echo "Source URL detected as Git repository. Cloning..."
            if ! git clone "$CLIENT_ASSEST_URL" source; then
              send_failure_callback "Failed to clone Git repository from $CLIENT_ASSEST_URL."
            fi
            
          # Check if the URL contains .zip to assume it's a compressed file
          elif [[ "$CLIENT_ASSEST_URL" == *".zip"* ]]; then
            echo "Source URL detected as Zip file. Downloading and extracting..."
            
            # Use curl for downloading on macOS instances.
            if ! curl -L -o source.zip "$CLIENT_ASSEST_URL"; then
              send_failure_callback "Failed to download zip file from $CLIENT_ASSEST_URL."
            fi
            
            mkdir -p source
            if ! unzip -q source.zip -d source; then
              send_failure_callback "Failed to extract zip file."
            fi

          else
            send_failure_callback "Source URL $CLIENT_ASSEST_URL is neither a Git repository nor a Zip file."
          fi
          
          echo "Source code fetched successfully."

      - name: 2. Detect Framework and Build Web Project
        script: |
          #!/bin/bash
          # Load previously defined functions
          . /tmp/callback_functions.sh

          # Ensure we are in the source directory
          cd source || send_failure_callback "Failed to navigate into source directory."
          
          # Handle common case where zip/clone results in a single sub-directory (flatten structure)
          if [[ $(find . -maxdepth 1 -mindepth 1 -type d | wc -l) -eq 1 ]]; then
              DIR_TO_MOVE=$(find . -maxdepth 1 -mindepth 1 -type d)
              echo "Detected single top-level directory ($DIR_TO_MOVE), flattening structure."
              mv "$DIR_TO_MOVE"/* .
              rmdir "$DIR_TO_MOVE"
          fi

          if [ ! -f package.json ]; then
            send_failure_callback "Could not find package.json in the source code root. Cannot determine framework."
          fi
          
          echo "Installing Node dependencies..."
          if ! npm install; then
            send_failure_callback "npm install failed. Check project dependencies."
          fi

          PACKAGE_CONTENT=$(cat package.json)
          FRAMEWORK=""
          DIST_FOLDER=""

          # Logic to detect common web frameworks
          if echo "$PACKAGE_CONTENT" | grep -q '"next"'; then
            FRAMEWORK="Next.js"
            DIST_FOLDER=".next"
          elif echo "$PACKAGE_CONTENT" | grep -q '"react"' && echo "$PACKAGE_CONTENT" | grep -q '"react-scripts"'; then
            FRAMEWORK="CRA-React"
            DIST_FOLDER="build"
          elif echo "$PACKAGE_CONTENT" | grep -q '"react"' && echo "$PACKAGE_CONTENT" | grep -q '"vite"'; then
            FRAMEWORK="Vite-React"
            DIST_FOLDER="dist"
          elif echo "$PACKAGE_CONTENT" | grep -q '"vue"'; then
            FRAMEWORK="Vue.js"
            DIST_FOLDER="dist"
          else
            send_failure_callback "Unsupported framework detected. Only Next.js, React, and Vue.js are supported."
          fi

          echo "Detected Framework: $FRAMEWORK."

          # --- ENHANCED BUILD LOGIC WITH FALLBACK ---
          BUILD_SUCCESS=0
          
          # 1. Attempt standard 'npm run build' first
          echo "Attempting standard build: npm run build"
          if npm run build; then
            echo "Standard 'npm run build' successful."
            BUILD_SUCCESS=1
          else
            echo "Standard 'npm run build' failed (Missing script or execution error). Trying framework-specific fallback..."
            
            # 2. Try framework-specific fallback commands using npx
            case "$FRAMEWORK" in
              "Next.js")
                echo "Trying 'npx next build'..."
                if npx next build; then BUILD_SUCCESS=1; fi
                ;;
              "CRA-React")
                echo "Trying 'npx react-scripts build'..."
                if npx react-scripts build; then BUILD_SUCCESS=1; fi
                ;;
              "Vite-React"|"Vue.js")
                echo "Trying 'npx vite build'..."
                if npx vite build; then BUILD_SUCCESS=1; fi
                ;;
              *)
                echo "No framework-specific fallback available."
                ;;
            esac
          fi
          
          # Check if the build ultimately failed
          if [ $BUILD_SUCCESS -eq 0 ]; then
            send_failure_callback "Build failed for $FRAMEWORK project. The 'build' script is missing and framework-specific fallbacks also failed."
          fi
          # --- END ENHANCED BUILD LOGIC ---

          
          # Check for the distribution folder existence
          if [ ! -d $DIST_FOLDER ]; then
            send_failure_callback "Build succeeded, but the expected distribution folder ($DIST_FOLDER) was not found."
          fi
          
          # Save the detected folder name to a temporary file for the publishing step
          echo $DIST_FOLDER > /tmp/dist_folder_name.txt 
          
          echo "Web project built successfully. Distribution folder: $DIST_FOLDER"


    # Artifacts section: Tells Codemagic what file to upload and make available
    artifacts:
      - web-app-dist.zip
    
    publishing:
      scripts:
        - name: 3. Zip Artifact and Final Success Callback
          script: |
            #!/bin/bash
            # Load previously defined functions
            . /tmp/callback_functions.sh

            # Ensure we are in the source directory to access the distribution folder
            cd source || send_failure_callback "Failed to navigate into source directory for zipping."
            
            # Load the detected distribution folder name from /tmp
            DIST_FOLDER=$(cat /tmp/dist_folder_name.txt)
            OUTPUT_ZIP_NAME="web-app-dist.zip"
            
            echo "Zipping the distribution folder ($DIST_FOLDER) into $OUTPUT_ZIP_NAME..."
            
            # Zip the contents of the distribution folder. 
            # We move the zip file one directory up (to the root of the build) 
            # so Codemagic finds it easily based on the 'artifacts' setting.
            if ! zip -r "../$OUTPUT_ZIP_NAME" "$DIST_FOLDER"; then
              echo "ERROR: Failed to zip the distribution folder $DIST_FOLDER."
              exit 1
            fi
            
            echo "Artifact successfully created: $OUTPUT_ZIP_NAME"
            
            # Send the final success callback.
            send_callback "success" "Build completed, artifact successfully published." "$CM_ARTIFACT_URL"
            
            echo "Final callback finished."